<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title class="titleText">Web GPU prototyping</title>
        <meta name="description" content="learning WebGPU" />
        <meta name="author" content="Mike Reinstein" />
        <meta name="viewport" content="width=device-width" />
        <meta name="viewport" content="initial-scale=1, maximum-scale=1" />

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />

        <style>
            
            body {
                padding: 0;
                margin: 0;
            }

            img {
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-crisp-edges;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }

            .viewport-container {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;

                display: flex;
                align-items: center;
                justify-content: center;
            }

            canvas {
                background-color: green;
                border: none;
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-crisp-edges;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }

            canvas::-webkit-scrollbar {
                display: none;
            }

        </style>
    </head>
    <body>
        
        <div class="viewport-container">
            <canvas id="viewport" width="480" height="270"></canvas>
        </div>

<script type="module">
import Game             from './Game.js'
import * as SpriteData  from './SpriteData.js'
import * as Cobalt      from '../bundle.js'
import constants        from './constants.js'
import dat              from 'https://cdn.skypack.dev/pin/dat.gui@v0.7.9-2wtQAdFH5SRwnJLDWGNz/mode=imports,min/optimized/dat.gui.js'
import debounce         from 'https://cdn.skypack.dev/pin/lodash.debounce@v4.0.8-4GXU9B066R3Th6HmjZmO/lodash.debounce.js'
import animationSystem  from './system-animation.js'
import rendererSystem   from './system-renderer.js'
import spriteEntity     from './entity-sprite.js'
import { ECS, vec2 }    from './deps.js'


async function main () {

    const [ spritesheetJson, layers ] = await Promise.all([
        fetchJson('./assets/spritesheet.json'),
        SpriteData.loadSpriteLayers('assets/sprite-layers.xt')
    ])

    Game.layers = new Array(Object.keys(layers).length)

    for (const layerName in layers) {
        const layer = layers[layerName]
        Game.layers[layer.zIndex] = { name: layerName, type: layer.type}
    }

    
    //Game.spritesheet = readSpriteSheet(spritesheetJson)

    const canvas = document.querySelector('canvas')

    const viewportWidth = constants.GAME_WIDTH
    const viewportHeight = constants.GAME_HEIGHT
    Game.renderer = await Cobalt.create(canvas, viewportWidth, viewportHeight)

    //Cobalt.setViewportDimensions(Game.renderer, constants.GAME_WIDTH, constants.GAME_HEIGHT)

    const spriteTextureUrl = 'assets/spritesheet.png'
    const emissiveSpriteTextureUrl = 'assets/spritesheet_emissive.png'
    //const spritesheetJson = await fetchJson('/assets/spritesheet.json')
    await Cobalt.configureSpriteRenderer(Game.renderer, spritesheetJson, spriteTextureUrl, emissiveSpriteTextureUrl)

    
    Cobalt.configureLayers(Game.renderer, Game.layers)
    /*
    Cobalt.configureLayers(Renderer.cobalt, [
        { name: 'background2', type: 'tile' },
        { name: 'background', type: 'tile' },
        { name: 'details3', type: 'tile' },
        { name: 'details2', type: 'tile' },
        { name: 'movingplatformback', type: 'sprite' },
        { name: 'details', type: 'tile' },
        { name: 'chests', type: 'sprite' },
        { name: 'breakables', type: 'tile' },
        { name: 'particles', type: 'sprite' },
        { name: 'projectiles', type: 'sprite' },
        { name: 'enemies', type: 'sprite' },
        { name: 'platforms2', type: 'tile' },
        { name: 'platforms', type: 'tile' },
        { name: 'hero', type: 'sprite' },
        { name: 'frontdetails', type: 'tile' },
        { name: 'water', type: 'tile' },
        { name: 'movingwater', type: 'sprite' },
        { name: 'effects', type: 'sprite' },
        { name: 'closingdoor', type: 'tile' },
        { name: 'walls', type: 'tile' },
        { name: 'uibackground', type: 'sprite' },
        { name: 'ui', type: 'sprite' },
        { name: 'hud', type: 'overlay' },
        { name: 'overlay', type: 'overlay' },
    ])
    */

    //                                                  atlasTextureUrl                         tileSize  tileScale
    await Cobalt.configureTileRenderer(Game.renderer, `assets/spelunky-tiles-extruded.png`,   16,       1.0)

    //                                       scrollScale  tileMapTextureUrl                       zIndex
    //await Cobalt.addTileLayer(Game.renderer, 1.0,         `data:image/png;base64,${b64Encoded}`,  zIndex)
    await Cobalt.addTileLayer(Game.renderer, 1.0,         `assets/spelunky0.png`,  5)
    await Cobalt.addTileLayer(Game.renderer, 0.6,         `assets/spelunky1.png`,  0)



    // use resizeViewport to init values on load:
    resizeViewport(Game.renderer, window.innerWidth, window.innerHeight)

    // window resize is *expensive* - best to debounce:
    const debouncedResize = debounce(function () {
       resizeViewport(Game.renderer, window.innerWidth, window.innerHeight) 
    }, 50)

    window.addEventListener('resize', debouncedResize, { passive: true })


    const world = ECS.createWorld()
    ECS.addSystem(world, rendererSystem(Game.renderer))
    ECS.addSystem(world, animationSystem)


    const gui = new dat.GUI()
    const config = {
        bloom_intensity: 40.0,
        bloom_combine_constant: 0.68,
        bloom_knee: 0.2,
        bloom_threshold: 0.1, // 1.0

        // sprite instance 1
        sprite_instances: [
            {
                emissive_intensity: 1.0,
            },
            {
                emissive_intensity: 0.5,
            },
        ],
    }

    gui.add(config, 'bloom_intensity', 0, 200).onChange((v) => {
        updateFinalParams(config.bloom_intensity, config.bloom_combine_constant, config.bloom_knee, config.bloom_threshold)
    })

    gui.add(config, 'bloom_combine_constant', 0.0, 1.0).onChange((v) => {
        updateFinalParams(config.bloom_intensity, config.bloom_combine_constant, config.bloom_knee, config.bloom_threshold)
    })

    gui.add(config, 'bloom_knee', 0.0, 50.0).onChange((v) => {
        updateFinalParams(config.bloom_intensity, config.bloom_combine_constant, config.bloom_knee, config.bloom_threshold)
    })

    gui.add(config, 'bloom_threshold', 0.0, 1.0).onChange((v) => {
        updateFinalParams(config.bloom_intensity, config.bloom_combine_constant, config.bloom_knee, config.bloom_threshold)
    })

    const updateFinalParams = function (bloom_intensity=40.0, bloom_combine_constant=0.68, bloom_knee=0.2, bloom_threshold=0.1) {
        const device = Game.renderer.device
        const params_buf = Game.renderer.postProcessing.params_buf

        device.queue.writeBuffer(
            params_buf,
            0,
            new Float32Array([ bloom_intensity, bloom_combine_constant ])
        )

        device.queue.writeBuffer(
            Game.renderer.bloom.params_buf,
            0,
            new Float32Array([ bloom_threshold,
                                bloom_threshold - bloom_knee,
                                bloom_knee * 2.0,
                                0.25 / bloom_knee,
                                bloom_combine_constant,
                                // require byte alignment bs
                                0,
                                0,
                                0, ])
        )
    }    

    /*
    ECS.addSystem(world, function cameraLoopSystem(world) {
        const onUpdate = function (dt) {
            const elapsed = performance.now()
            const x = (Math.sin(elapsed / 2000) * 0.5 + 0.5) * 128
            const y = (Math.sin(elapsed / 5000) * 0.5 + 0.5) * 170

            const { tileScale } = Game.renderer.tile

            vec2.set(Game.renderer.viewport.position, Math.floor(x * tileScale), Math.floor(y * tileScale))
        }

        return { onUpdate }
    })
    */
    

    Game.world = world

    // temporary test sprites

    const s2 = spriteEntity(world, { name: 'health_empty-0.png', position: [ 50, 50 ], zIndex: 4, emissiveIntensity: 0.5, width: 14, height: 15 })

    const s = spriteEntity(world, { name: 'health-0.png', position: [ 240, 135 ], zIndex: 4, emissiveIntensity: 0.5, width: 14, height: 15 })

    //s.sprite.scale[0] = 2
    //s.sprite.scale[1] = 2

    const gameLoop = function () {
        tick(Game)
        requestAnimationFrame(gameLoop)
    }

    requestAnimationFrame(gameLoop)
}


function tick (context) {
    const newTime = performance.now()
    const frameTime = newTime - context.lastFrameTime
    context.lastFrameTime = newTime
    ECS.update(context.world, frameTime)
    ECS.cleanup(context.world)
}


async function fetchJson (url) {
    const raw = await fetch(url)
    return raw.json()
}


function resizeViewport (renderer, width, height) {

    const { canvas } = renderer

    // determine which screen dimension is most constrained
    // we floor the render scale to an integer because we get weird texture artifacts when trying to render at
    // certain float values (e.g., 3.0145833333333334)
    const renderScale = Math.floor(Math.min(width/constants.GAME_WIDTH, height/constants.GAME_HEIGHT))

    canvas.width = Math.ceil(constants.GAME_WIDTH)
    canvas.height = Math.ceil(constants.GAME_HEIGHT)

    Cobalt.setViewportDimensions(renderer, constants.GAME_WIDTH, constants.GAME_HEIGHT)

    // https://www.khronos.org/webgl/wiki/HandlingHighDPI
    // webgl display resolution size within canvas
    const resolution = window.devicePixelRatio || 1

    // center the canvas if native window doesn't match aspect ratio
    canvas.style.width = canvas.width * renderScale + 'px'
    canvas.style.height = canvas.height * renderScale + 'px'
    
    canvas.style.left = Math.round((width - canvas.width * renderScale) / 2) + 'px'
    canvas.style.top = Math.round((height - canvas.height * renderScale) / 2) + 'px'
}


main()

</script>


    </body>
</html>
