<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title class="titleText">WebGPU - Cobalt real time point lighting and shadow casting</title>
        <meta name="description" content="Web GPU 2d cobalt" />
        <meta name="author" content="Michael Reinstein" />
        <meta name="viewport" content="width=device-width" />
        <meta name="viewport" content="initial-scale=1, maximum-scale=1" />

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="mobile-web-app-capable" content="yes" />

        <style>
            
            body {
                padding: 0;
                margin: 0;
                overscroll-behavior: none;
            }

            img {
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-crisp-edges;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }

            .viewport-container {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;

                display: flex;
                align-items: center;
                justify-content: center;
            }

            canvas {
                background-color: green;
                border: none;
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-crisp-edges;
                image-rendering: pixelated;
                image-rendering: crisp-edges;
            }

            canvas::-webkit-scrollbar {
                display: none;
            }

            /* pin dat.gui to top-left so it doesn't fight the canvas */
            .dg.ac {
                top: 8px !important;
                left: 8px !important;
                right: auto !important;
            }

        </style>
    </head>
    <body>
        
        Drag the mouse to create a shadow segment.

        <div class="viewport-container">
            <canvas id="viewport" width="480" height="270"></canvas>
        </div>

<script type="module">
import Global      from './Global.js'
import * as Cobalt from '../../bundle.js'
import constants   from './constants.js'
import dat         from 'https://cdn.skypack.dev/pin/dat.gui@v0.7.9-2wtQAdFH5SRwnJLDWGNz/mode=imports,min/optimized/dat.gui.js'
import debounce    from 'https://cdn.skypack.dev/pin/lodash.debounce@v4.0.8-4GXU9B066R3Th6HmjZmO/lodash.debounce.js'
import { ECS }     from './deps.js'

let mouseViewportPosition = [0, 0];
const mouseButtonsDown = new Map();

async function main () {

    const canvas = document.querySelector('canvas')

    const viewportWidth = constants.GAME_WIDTH
    const viewportHeight = constants.GAME_HEIGHT
    Global.renderer = await Cobalt.init(canvas, viewportWidth, viewportHeight)
    Global.renderer.viewport.zoom = 1;

    const viewportCenter = [0, 0];

    // instantiate all resource nodes
    const tileAtlasNode = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:tileAtlas',
        refs: { },
        options: {
            label: 'tile atlas',
            tileSize: 16,
            tileScale: 1.0,
            textureUrl: 'assets/spelunky-tiles.png',
            outputFormat: 'rgba16float',
        }
    })

    const hdrTex = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:fbTexture',
        refs: { },
        options: {
            label: 'hdr color texture',
            format: 'rgba16float',
            mip_count: 1,
            viewportScale: 1.0,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING,
        }
    })

    const lightCompositeHdrTex = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:fbTexture',
        refs: { },
        options: {
            label: 'hdr + lighting/shadows color texture',
            format: 'rgba16float',
            mip_count: 1,
            viewportScale: 1.0,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING,
        }
    })

    // instantiate all runnable nodes
    const tileNode = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:tileHDR',
        refs: {
            // key is the var name defined in this node
            // value is the var name in the cobalt resources dictionary
            tileAtlas: tileAtlasNode,
            out: hdrTex,
        },
        options: {
            textureUrl: 'assets/spelunky1.png',
            scrollScale: 0.6,
        }
    })

    const tileNode2 = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:tileHDR',
        refs: {
            // key is the var name defined in this node
            // value is the var name in the cobalt resources dictionary
            tileAtlas: tileAtlasNode,
            out: hdrTex,
        },
        options: {
            textureUrl: 'assets/spelunky0.png',
            scrollScale: 1.0,
        }
    })

    // lights and shadows node
    const light = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:light',
        refs: {
            in: hdrTex,
            out: lightCompositeHdrTex,
        },
        options: {
        }
    })

    const b = await Cobalt.initNode(Global.renderer, {
        type: 'cobalt:fbBlit',
        refs: {
            in: lightCompositeHdrTex,
            out: 'FRAME_TEXTURE_VIEW',
        },
        options: { }
    })


    light.setAmbientLight([0.3, 0.3, 0.3]);

    const permanentObstacleSegments = [];
    
    let temporaryObstacleSegment = null;

    const allOccluders = () => {
        const segments = [
            ...permanentObstacleSegments,
        ];
        if (temporaryObstacleSegment) {
            segments.push(temporaryObstacleSegment);
        }

        return segments;

    };

    const convertToViewportPosition = (clientPosition /* [number, number] */) /* [number, number] */ => {
        const canvasBox = canvas.getBoundingClientRect();
        return [
             ((clientPosition[0] - canvasBox.left) / canvasBox.width) * constants.GAME_WIDTH  /Global.renderer.viewport.zoom,
             ((clientPosition[1] - canvasBox.top) / canvasBox.height) * constants.GAME_HEIGHT /Global.renderer.viewport.zoom,
        ];
    }

    const convertToWorldPosition = (viewportPosition /* [number, number] */) /* [number, number] */ => {
        return [
            viewportPosition[0] + viewportCenter[0] - 0.5 * constants.GAME_WIDTH / Global.renderer.viewport.zoom,
            viewportPosition[1] + viewportCenter[1] - 0.5 * constants.GAME_HEIGHT/ Global.renderer.viewport.zoom,
        ];
    };

    canvas.addEventListener("mouseenter", event => {
        mouseViewportPosition = convertToViewportPosition([event.clientX, event.clientY]);
    });

    canvas.addEventListener("mousedown", event => {
        mouseButtonsDown.set(event.button, true);

        if (event.button === 0) {
            temporaryObstacleSegment = [
                convertToWorldPosition(mouseViewportPosition),
                convertToWorldPosition(mouseViewportPosition),
            ];
        }
    });

    canvas.addEventListener("mouseup", event => {
        mouseButtonsDown.set(event.button, false);

        if (temporaryObstacleSegment) {
            permanentObstacleSegments.push(temporaryObstacleSegment);
            temporaryObstacleSegment = null;
            light.setOccluders(allOccluders());
        }
    });

    canvas.addEventListener("mouseleave", event => {
        for (const key of mouseButtonsDown.keys()) {
            mouseButtonsDown.set(key, false);
        }
    });

    canvas.addEventListener("mousemove", event => {
        const newMouseViewportPosition = convertToViewportPosition([event.clientX, event.clientY]);
        const movement = [
            newMouseViewportPosition[0] - mouseViewportPosition[0],
            newMouseViewportPosition[1] - mouseViewportPosition[1],
        ];
        mouseViewportPosition = newMouseViewportPosition;

        if (mouseButtonsDown.get(1) === true) {
            viewportCenter[0] -= movement[0];
            viewportCenter[1] -= movement[1];

            Cobalt.setViewportPosition(Global.renderer, viewportCenter)
        }

        if (temporaryObstacleSegment) {
            temporaryObstacleSegment[1] = convertToWorldPosition(mouseViewportPosition);
            light.setOccluders(allOccluders());
        }
    });
    
    const mouseLight = {
        position: convertToWorldPosition(mouseViewportPosition),
        radius: 100,
        color: [1, 1, 1],
        intensity: 20,
        attenuationLinear: 0,
        attenuationExp: 5,
    };

    canvas.addEventListener("wheel", event => {
        mouseLight.intensity *= 1 + 0.001 * event.deltaY;
    });

    const movingRedLight = {
        position: [ 69, 42 ],
        radius: 150,
        color: [1, 0, 0],
        intensity: 2,
        attenuationLinear: 0,
        attenuationExp: 7,
    };

    const movingGreenLight = {
        position: [ 69, 42 ],
        radius: 50,
        color: [0, 1, 0],
        intensity: 10,
        attenuationLinear: 0,
        attenuationExp: 3,
    };

    const lights = [
        mouseLight,
        movingRedLight,
        movingGreenLight,
    ];
    light.setLights(lights)


    // ---- dat.gui tweakable panel ----

    const gui = new dat.GUI({ name: 'Lighting' })

    // ambient light (dat.gui color expects a hex string)
    const ambientParams = { color: '#4d4d4d' }
    const hexToRgb01 = hex => {
        const n = parseInt(hex.slice(1), 16)
        return [(n >> 16 & 255) / 255, (n >> 8 & 255) / 255, (n & 255) / 255]
    }
    const rgb01ToHex = ([r, g, b]) =>
        '#' + [r, g, b].map(v => Math.round(v * 255).toString(16).padStart(2, '0')).join('')

    ambientParams.color = rgb01ToHex([0.3, 0.3, 0.3])
    const ambientFolder = gui.addFolder('Ambient')
    ambientFolder.addColor(ambientParams, 'color').name('color').onChange(v => {
        light.setAmbientLight(hexToRgb01(v))
    })
    ambientFolder.open()

    // helper: add a folder for a single light object
    const addLightFolder = (folder, lightObj, colorHex) => {
        const params = { color: colorHex }
        folder.addColor(params, 'color').name('color').onChange(v => {
            lightObj.color = hexToRgb01(v)
        })
        folder.add(lightObj, 'intensity', 0, 50).name('intensity')
        folder.add(lightObj, 'radius', 1, 512).name('radius')
        folder.add(lightObj, 'attenuationLinear', 0, 1).name('attn linear')
        folder.add(lightObj, 'attenuationExp', 0, 200).name('attn exp')
    }

    const mouseLightFolder = gui.addFolder('Mouse light')
    addLightFolder(mouseLightFolder, mouseLight, rgb01ToHex(mouseLight.color))
    mouseLightFolder.open()

    const redLightFolder = gui.addFolder('Red light')
    addLightFolder(redLightFolder, movingRedLight, rgb01ToHex(movingRedLight.color))
    const redAnim = { animated: true }
    redLightFolder.add(redAnim, 'animated').name('animated')

    const greenLightFolder = gui.addFolder('Green light')
    addLightFolder(greenLightFolder, movingGreenLight, rgb01ToHex(movingGreenLight.color))
    const greenAnim = { animated: true }
    greenLightFolder.add(greenAnim, 'animated').name('animated')

    // ---- end gui ----


    // use resizeViewport to init values on load:
    resizeViewport(Global.renderer, window.innerWidth, window.innerHeight)

    // window resize is *expensive* - best to debounce:
    const debouncedResize = debounce(function () {
       resizeViewport(Global.renderer, window.innerWidth, window.innerHeight) 
    }, 50)

    window.addEventListener('resize', debouncedResize, { passive: true })


    
    const world = ECS.createWorld()

    ECS.addSystem(world, function rendererSystem (world) {
        const onUpdate = function (/*dt*/) {

            mouseLight.position = convertToWorldPosition(mouseViewportPosition);

            if (greenAnim.animated) {
                movingGreenLight.position = [
                    80 * Math.cos(performance.now() / 500),
                    80 * Math.sin(performance.now() / 500),
                ];
            }

            if (redAnim.animated) {
                movingRedLight.position = [
                    40 * Math.cos(performance.now() / 500),
                    60,
                ];
            }
            light.setLights(lights)

            Cobalt.draw(Global.renderer)
        }

        return { onUpdate }
    })

    Cobalt.setViewportPosition(Global.renderer, viewportCenter)
    
    ECS.addSystem(world, function cameraLoopSystem(world) {
        const onUpdate = function (dt) {
            // const elapsed = performance.now()
            // const x = (Math.sin(elapsed / 2000) * 0.5 + 0.5) * 128
            // const y = (Math.sin(elapsed / 5000) * 0.5 + 0.5) * 170

            // Cobalt.setViewportPosition(Global.renderer, [ x, y ])
        }

        return { onUpdate }
    })

    Global.world = world


    const gameLoop = function () {
        tick(Global)
        requestAnimationFrame(gameLoop)
    }


    requestAnimationFrame(gameLoop)
}


function tick (context) {
    const newTime = performance.now()
    const frameTime = newTime - context.lastFrameTime
    context.lastFrameTime = newTime
    ECS.update(context.world, frameTime)
    ECS.cleanup(context.world)
}


function resizeViewport (renderer, width, height) {
    // reset mouse position
    mouseViewportPosition[0] = 0;
    mouseViewportPosition[1] = 0;

    const { canvas, device } = renderer

    // determine which screen dimension is most constrained
    // we floor the render scale to an integer because we get weird texture artifacts when trying to render at
    // certain float values (e.g., 3.0145833333333334)
    const renderScale = Math.floor(Math.min(width/constants.GAME_WIDTH, height/constants.GAME_HEIGHT))

    canvas.width = Math.ceil(constants.GAME_WIDTH)
    canvas.height = Math.ceil(constants.GAME_HEIGHT)

    Cobalt.setViewportDimensions(renderer, constants.GAME_WIDTH, constants.GAME_HEIGHT)

    // https://www.khronos.org/webgl/wiki/HandlingHighDPI
    // webgl display resolution size within canvas
    const resolution = window.devicePixelRatio || 1

    // center the canvas if native window doesn't match aspect ratio
    canvas.style.width = canvas.width * renderScale + 'px'
    canvas.style.height = canvas.height * renderScale + 'px'
    
    canvas.style.left = Math.round((width - canvas.width * renderScale) / 2) + 'px'
    canvas.style.top = Math.round((height - canvas.height * renderScale) / 2) + 'px'
}


main()

</script>


    </body>
</html>
